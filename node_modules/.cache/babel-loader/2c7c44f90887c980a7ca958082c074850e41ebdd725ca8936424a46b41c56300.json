{"ast":null,"code":"import { OpenAIError } from \"../error.mjs\";\nimport { isAutoParsableResponseFormat } from \"../lib/parser.mjs\";\nexport function maybeParseResponse(response, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map(item => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null\n          };\n        }\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map(content => ({\n              ...content,\n              parsed: null\n            }))\n          };\n        } else {\n          return item;\n        }\n      })\n    };\n  }\n  return parseResponse(response, params);\n}\nexport function parseResponse(response, params) {\n  const output = response.output.map(item => {\n    if (item.type === 'function_call') {\n      return {\n        ...item,\n        parsed_arguments: parseToolCall(params, item)\n      };\n    }\n    if (item.type === 'message') {\n      const content = item.content.map(content => {\n        if (content.type === 'output_text') {\n          return {\n            ...content,\n            parsed: parseTextFormat(params, content.text)\n          };\n        }\n        return content;\n      });\n      return {\n        ...item,\n        content\n      };\n    }\n    return item;\n  });\n  const parsed = Object.assign({}, response, {\n    output\n  });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n      return null;\n    }\n  });\n  return parsed;\n}\nfunction parseTextFormat(params, content) {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format;\n    return text_format.$parseRaw(content);\n  }\n  return JSON.parse(content);\n}\nexport function hasAutoParseableInput(params) {\n  if (isAutoParsableResponseFormat(params.text?.format)) {\n    return true;\n  }\n  return false;\n}\nexport function makeParseableResponseTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nfunction getInputToolByName(input_tools, name) {\n  return input_tools.find(tool => tool.type === 'function' && tool.name === name);\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null\n  };\n}\nexport function shouldParseToolCall(params, toolCall) {\n  if (!params) {\n    return false;\n  }\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}\nexport function addOutputText(rsp) {\n  const texts = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n  rsp.output_text = texts.join('');\n}","map":{"version":3,"names":["OpenAIError","isAutoParsableResponseFormat","maybeParseResponse","response","params","hasAutoParseableInput","output_parsed","output","map","item","type","parsed_arguments","content","parsed","parseResponse","parseToolCall","parseTextFormat","text","Object","assign","getOwnPropertyDescriptor","addOutputText","defineProperty","enumerable","get","format","text_format","$parseRaw","JSON","parse","makeParseableResponseTool","tool","parser","callback","obj","defineProperties","$brand","value","$callback","isAutoParsableTool","getInputToolByName","input_tools","name","find","toolCall","inputTool","tools","arguments","strict","shouldParseToolCall","validateInputTools","function","rsp","texts","push","output_text","join"],"sources":["/Users/tato/repo/github/tatoflam/logo-generator-app/node_modules/openai/src/lib/ResponsesParser.ts"],"sourcesContent":["import { OpenAIError } from '../error';\nimport type { ChatCompletionTool } from '../resources/chat/completions';\nimport {\n  ResponseTextConfig,\n  type FunctionTool,\n  type ParsedContent,\n  type ParsedResponse,\n  type ParsedResponseFunctionToolCall,\n  type ParsedResponseOutputItem,\n  type Response,\n  type ResponseCreateParamsBase,\n  type ResponseCreateParamsNonStreaming,\n  type ResponseFunctionToolCall,\n  type Tool,\n} from '../resources/responses/responses';\nimport { type AutoParseableTextFormat, isAutoParsableResponseFormat } from '../lib/parser';\n\nexport type ParseableToolsParams = Array<Tool> | ChatCompletionTool | null;\n\nexport type ResponseCreateParamsWithTools = ResponseCreateParamsBase & {\n  tools?: ParseableToolsParams;\n};\n\ntype TextConfigParams = { text?: ResponseTextConfig };\n\nexport type ExtractParsedContentFromParams<Params extends TextConfigParams> =\n  NonNullable<Params['text']>['format'] extends AutoParseableTextFormat<infer P> ? P : null;\n\nexport function maybeParseResponse<\n  Params extends ResponseCreateParamsBase | null,\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...response,\n      output_parsed: null,\n      output: response.output.map((item) => {\n        if (item.type === 'function_call') {\n          return {\n            ...item,\n            parsed_arguments: null,\n          };\n        }\n\n        if (item.type === 'message') {\n          return {\n            ...item,\n            content: item.content.map((content) => ({\n              ...content,\n              parsed: null,\n            })),\n          };\n        } else {\n          return item;\n        }\n      }),\n    };\n  }\n\n  return parseResponse(response, params);\n}\n\nexport function parseResponse<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(response: Response, params: Params): ParsedResponse<ParsedT> {\n  const output: Array<ParsedResponseOutputItem<ParsedT>> = response.output.map(\n    (item): ParsedResponseOutputItem<ParsedT> => {\n      if (item.type === 'function_call') {\n        return {\n          ...item,\n          parsed_arguments: parseToolCall(params, item),\n        };\n      }\n      if (item.type === 'message') {\n        const content: Array<ParsedContent<ParsedT>> = item.content.map((content) => {\n          if (content.type === 'output_text') {\n            return {\n              ...content,\n              parsed: parseTextFormat(params, content.text),\n            };\n          }\n\n          return content;\n        });\n\n        return {\n          ...item,\n          content,\n        };\n      }\n\n      return item;\n    },\n  );\n\n  const parsed: Omit<ParsedResponse<ParsedT>, 'output_parsed'> = Object.assign({}, response, { output });\n  if (!Object.getOwnPropertyDescriptor(response, 'output_text')) {\n    addOutputText(parsed);\n  }\n\n  Object.defineProperty(parsed, 'output_parsed', {\n    enumerable: true,\n    get() {\n      for (const output of parsed.output) {\n        if (output.type !== 'message') {\n          continue;\n        }\n\n        for (const content of output.content) {\n          if (content.type === 'output_text' && content.parsed !== null) {\n            return content.parsed;\n          }\n        }\n      }\n\n      return null;\n    },\n  });\n\n  return parsed as ParsedResponse<ParsedT>;\n}\n\nfunction parseTextFormat<\n  Params extends ResponseCreateParamsBase,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(params: Params, content: string): ParsedT | null {\n  if (params.text?.format?.type !== 'json_schema') {\n    return null;\n  }\n\n  if ('$parseRaw' in params.text?.format) {\n    const text_format = params.text?.format as unknown as AutoParseableTextFormat<ParsedT>;\n    return text_format.$parseRaw(content);\n  }\n\n  return JSON.parse(content);\n}\n\nexport function hasAutoParseableInput(params: ResponseCreateParamsWithTools): boolean {\n  if (isAutoParsableResponseFormat(params.text?.format)) {\n    return true;\n  }\n\n  return false;\n}\n\ntype ToolOptions = {\n  name: string;\n  arguments: any;\n  function?: ((args: any) => any) | undefined;\n};\n\nexport type AutoParseableResponseTool<\n  OptionsT extends ToolOptions,\n  HasFunction = OptionsT['function'] extends Function ? true : false,\n> = FunctionTool & {\n  __arguments: OptionsT['arguments']; // type-level only\n  __name: OptionsT['name']; // type-level only\n\n  $brand: 'auto-parseable-tool';\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\n  $parseRaw(args: string): OptionsT['arguments'];\n};\n\nexport function makeParseableResponseTool<OptionsT extends ToolOptions>(\n  tool: FunctionTool,\n  {\n    parser,\n    callback,\n  }: {\n    parser: (content: string) => OptionsT['arguments'];\n    callback: ((args: any) => any) | undefined;\n  },\n): AutoParseableResponseTool<OptionsT['arguments']> {\n  const obj = { ...tool };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n    $callback: {\n      value: callback,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableResponseTool<OptionsT['arguments']>;\n}\n\nexport function isAutoParsableTool(tool: any): tool is AutoParseableResponseTool<any> {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\n\nfunction getInputToolByName(input_tools: Array<Tool>, name: string): FunctionTool | undefined {\n  return input_tools.find((tool) => tool.type === 'function' && tool.name === name) as\n    | FunctionTool\n    | undefined;\n}\n\nfunction parseToolCall<Params extends ResponseCreateParamsBase>(\n  params: Params,\n  toolCall: ResponseFunctionToolCall,\n): ParsedResponseFunctionToolCall {\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n\n  return {\n    ...toolCall,\n    ...toolCall,\n    parsed_arguments:\n      isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments)\n      : inputTool?.strict ? JSON.parse(toolCall.arguments)\n      : null,\n  };\n}\n\nexport function shouldParseToolCall(\n  params: ResponseCreateParamsNonStreaming | null | undefined,\n  toolCall: ResponseFunctionToolCall,\n): boolean {\n  if (!params) {\n    return false;\n  }\n\n  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);\n  return isAutoParsableTool(inputTool) || inputTool?.strict || false;\n}\n\nexport function validateInputTools(tools: ChatCompletionTool[] | undefined) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\n      );\n    }\n\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\n      );\n    }\n  }\n}\n\nexport function addOutputText(rsp: Response): void {\n  const texts: string[] = [];\n  for (const output of rsp.output) {\n    if (output.type !== 'message') {\n      continue;\n    }\n\n    for (const content of output.content) {\n      if (content.type === 'output_text') {\n        texts.push(content.text);\n      }\n    }\n  }\n\n  rsp.output_text = texts.join('');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}